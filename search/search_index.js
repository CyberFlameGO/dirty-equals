var __index = Promise.resolve({"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+","tags":false},"docs":[{"location":"","text":"<p>  </p> <p> Doing dirty (but extremely useful) things with equals. </p> <p>                </p>   <p> Work in Progress</p> <p>This documentation site is currently incomplete, I'll try and finish the basic docs over the next few weeks.</p> <p>If you need help using as-yet undocumented types, please review the  code and  unit tests.</p> <p>Or, if you're a real saint, submit a pull request to add the missing documentation. </p>  <p>dirty-equals is a python library that (mis)uses the <code>__eq__</code> method to make python code (generally unit tests) more declarative and therefore easier to read and write.</p> <p>dirty-equals can be used in whatever context you like, but it comes into its own when writing unit tests for applications where you're commonly checking the response to API calls and the contents of a database.</p>","title":"Introduction"},{"location":"#usage","text":"<p>Here's a trivial example of what dirty-equals can do:</p> Trival Usage<pre><code>from dirty_equals import IsPositive\n\nassert 1 == IsPositive #(1)!\nassert -2 == IsPositive  # this will fail! (2)\n</code></pre> <ol> <li>This <code>assert</code> will pass since <code>1</code> is indeed positive, so the result of <code>1 == IsPositive</code> is <code>True</code>.</li> <li>This will fail (raise a <code>AssertionError</code>) since <code>-2</code> is not positive,     so the result of <code>-2 == IsPositive</code> is <code>False</code>.</li> </ol> <p>Not that interesting yet!, but consider the following unit test code using dirty-equals:</p> More Powerful Usage<pre><code>from dirty_equals import IsJson, IsNow, IsPositiveInt, IsStr\n\ndef test_user_endpoint(client: HttpClient, db_conn: Database): \n   client.pust('/users/create/', data=...)\n\n   user_data = db_conn.fetchrow('select * from users')\n   assert user_data == {\n       'id': IsPositiveInt, #(1)!\n       'username': 'samuelcolvin', #(2)!\n       'avatar_file': IsStr(regex=r'/[a-z0-9\\-]{10}/example\\.png'), #(3)!\n       'settings_json': IsJson({'theme': 'dark', 'language': 'en'}), #(4)!\n       'created_ts': IsNow(delta=3), #(5)!\n   }\n</code></pre> <ol> <li>We don't actually care what the <code>id</code> is, just that it's present, it's an <code>int</code> and it's positive.</li> <li>We can use a normal key and value here since we know exactly what value <code>username</code> should have before we test it.</li> <li><code>avatar_file</code> is a string, but we don't know all of the string before the <code>assert</code>,     just the format (regex) it should match.</li> <li><code>settings_json</code> is a <code>JSON</code> string, but it's simpler and more robust to confirm it represents a particular python    object rather than compare strings.</li> <li><code>created_at</code> is a <code>datetime</code>, although we don't know (or care) about its exact value;    since the user was just created we know it must be close to now. <code>delta</code> is optional, it defaults to 2 seconds.</li> </ol> <p>Without dirty-equals, you'd have to compare individual fields and/or modify some fields before comparison  - the test would not be declarative or as clear.</p> <p>dirty-equals can do so much more than that, for example:</p> <ul> <li><code>PartialDict</code> let's you compare a subset of a dictionary</li> <li><code>IsStrictDict</code> let's you confirm order in a dictionary</li> <li><code>IsList</code> and <code>IsTuple</code> lets you compare partial lists and tuples, with or without order constraints</li> <li>nesting any of these types inside any others</li> <li><code>IsInstance</code> lets you simply confirm the type of an object</li> <li>You can even use boolean operators <code>|</code> and <code>&amp;</code> to combine multiple conditions</li> <li>and much more...</li> </ul>","title":"Usage"},{"location":"#installation","text":"<p>Simply:</p> <pre><code>pip install dirty-equals\n</code></pre> <p>dirty-equals requires Python 3.7+.</p>","title":"Installation"},{"location":"types/","text":"","title":"Types"},{"location":"types/#numeric-types","text":"","title":"Numeric Types"},{"location":"types/#isint","text":"<p>Checks that a value is an integer, but not a bool (<code>True</code> or <code>False</code>) or a float.</p> IsInt<pre><code>from dirty_equals import IsInt\n\nassert 1 == IsInt\nassert -2 == IsInt\nassert 1.0 != IsInt\nassert 'foobar' != IsInt\nassert True != IsInt #(1)!\n</code></pre> <ol> <li>This might not be what you expect since <code>instance(True, int)</code> is <code>True</code> but to me, it doesn't make sense for booleans    to be allowed as integers in general.</li> </ol>","title":"<code>IsInt</code>"},{"location":"types/#isfloat","text":"<p>Checks that a value is a float.</p> IsFloat<pre><code>from dirty_equals import IsFloat\n\nassert 1.0 == IsFloat\nassert 1 != IsFloat\n</code></pre>","title":"<code>IsFloat</code>"},{"location":"types/#ispositive","text":"<p>Check that a value is positive (<code>&gt; 0</code>), can be an <code>int</code>, a <code>float</code> or a <code>Decimal</code>  (or indeed any value which implements <code>__gt__</code> for <code>0</code>).</p> IsPositive<pre><code>from decimal import Decimal\nfrom dirty_equals import IsPositive\n\nassert 1.0 == IsPositive\nassert 1 == IsPositive\nassert Decimal('3.14') == IsPositive\nassert 0 != IsPositive\nassert -1 != IsPositive\n</code></pre>","title":"<code>IsPositive</code>"},{"location":"types/#isnegative","text":"<p>Check that a value is negative (<code>&lt; 0</code>), can be an <code>int</code>, a <code>float</code> or a <code>Decimal</code>  (or indeed any value which implements <code>__lt__</code> for <code>0</code>).</p> IsNegative<pre><code>from decimal import Decimal\nfrom dirty_equals import IsNegative\n\nassert -1.0 == IsNegative\nassert -1 == IsNegative\nassert Decimal('-3.14') == IsNegative\nassert 0 != IsNegative\nassert 1 != IsNegative\n</code></pre>","title":"<code>IsNegative</code>"},{"location":"types/#isnonnegative","text":"<p>Check that a value is positive or zero (<code>&gt;= 0</code>), can be an <code>int</code>, a <code>float</code> or a <code>Decimal</code>  (or indeed any value which implements <code>__ge__</code> for <code>0</code>).</p> IsNonNegative<pre><code>from decimal import Decimal\nfrom dirty_equals import IsNonNegative\n\nassert 1.0 == IsNonNegative\nassert 1 == IsNonNegative\nassert Decimal('3.14') == IsNonNegative\nassert 0 == IsNonNegative\nassert -1 != IsNonNegative\nassert Decimal('0') == IsNonPositive\n</code></pre>","title":"<code>IsNonNegative</code>"},{"location":"types/#isnonpositive","text":"<p>Check that a value is negative or zero (<code>&lt;=0</code>), can be an <code>int</code>, a <code>float</code> or a <code>Decimal</code>  (or indeed any value which implements <code>__le__</code> for <code>0</code>).</p> IsNonPositive<pre><code>from decimal import Decimal\nfrom dirty_equals import IsNonPositive\n\nassert -1.0 == IsNonPositive\nassert -1 == IsNonPositive\nassert Decimal('-3.14') == IsNonPositive\nassert 0 == IsNonPositive\nassert 1 != IsNonPositive\nassert Decimal('-0') == IsNonPositive\nassert Decimal('0') == IsNonPositive\n</code></pre>","title":"<code>IsNonPositive</code>"},{"location":"types/#ispositiveint","text":"<p>Like <code>IsPositive</code> but only for <code>int</code>s.</p> IsPositiveInt<pre><code>from decimal import Decimal\nfrom dirty_equals import IsPositiveInt\n\nassert 1 == IsPositiveInt\nassert 1.0 != IsPositiveInt\nassert Decimal('3.14') != IsPositiveInt\nassert 0 != IsPositiveInt\nassert -1 != IsPositiveInt\n</code></pre>","title":"<code>IsPositiveInt</code>"},{"location":"types/#isnegativeint","text":"<p>Like <code>IsNegative</code> but only for <code>int</code>s.</p> IsNegativeInt<pre><code>from decimal import Decimal\nfrom dirty_equals import IsNegativeInt\n\nassert -1 == IsNegativeInt\nassert -1.0 != IsNegativeInt\nassert Decimal('-3.14') != IsNegativeInt\nassert 0 != IsNegativeInt\nassert 1 != IsNegativeInt\n</code></pre>","title":"<code>IsNegativeInt</code>"},{"location":"types/#ispositivefloat","text":"<p>Like <code>IsPositive</code> but only for <code>float</code>s.</p> IsPositiveFloat<pre><code>from decimal import Decimal\nfrom dirty_equals import IsPositiveFloat\n\nassert 1.0 == IsPositiveFloat\nassert 1 != IsPositiveFloat\nassert Decimal('3.14') != IsPositiveFloat\nassert 0.0 != IsPositiveFloat\nassert -1.0 != IsPositiveFloat\n</code></pre>","title":"<code>IsPositiveFloat</code>"},{"location":"types/#isnegativefloat","text":"<p>Like <code>IsNegative</code> but only for <code>float</code>s.</p> IsNegativeFloat<pre><code>from decimal import Decimal\nfrom dirty_equals import IsNegativeFloat\n\nassert -1.0 == IsNegativeFloat\nassert -1 != IsNegativeFloat\nassert Decimal('-3.14') != IsNegativeFloat\nassert 0.0 != IsNegativeFloat\nassert 1.0 != IsNegativeFloat\n</code></pre>","title":"<code>IsNegativeFloat</code>"},{"location":"types/#isapprox","text":"","title":"<code>IsApprox</code>"},{"location":"types/#isnumber","text":"","title":"<code>IsNumber</code>"},{"location":"types/#isnumeric","text":"","title":"<code>IsNumeric</code>"},{"location":"types/#date-and-time-types","text":"","title":"Date and Time Types"},{"location":"types/#isdatetime","text":"","title":"<code>IsDatetime</code>"},{"location":"types/#isnow","text":"","title":"<code>IsNow</code>"},{"location":"types/#dictionary-types","text":"","title":"Dictionary Types"},{"location":"types/#isdict","text":"","title":"<code>IsDict</code>"},{"location":"types/#ispartialdict","text":"","title":"<code>IsPartialDict</code>"},{"location":"types/#isstrictdict","text":"","title":"<code>IsStrictDict</code>"},{"location":"types/#list-and-tuples-types","text":"","title":"List and Tuples Types"},{"location":"types/#haslen","text":"","title":"<code>HasLen</code>"},{"location":"types/#islist","text":"","title":"<code>IsList</code>"},{"location":"types/#istuple","text":"","title":"<code>IsTuple</code>"},{"location":"types/#islistortuple","text":"","title":"<code>IsListOrTuple</code>"},{"location":"types/#string-types","text":"","title":"String Types"},{"location":"types/#isstr","text":"","title":"<code>IsStr</code>"},{"location":"types/#isbytes","text":"","title":"<code>IsBytes</code>"},{"location":"types/#isanystr","text":"","title":"<code>IsAnyStr</code>"},{"location":"types/#other-types","text":"","title":"Other Types"},{"location":"types/#functioncheck","text":"","title":"<code>FunctionCheck</code>"},{"location":"types/#isinstance","text":"","title":"<code>IsInstance</code>"},{"location":"types/#isjson","text":"","title":"<code>IsJson</code>"},{"location":"types/#isuuid","text":"","title":"<code>IsUUID</code>"},{"location":"types/#anything","text":"","title":"<code>AnyThing</code>"},{"location":"usage/","text":"<p>To do:</p> <ul> <li>initialised comparison vs. bare class comparison</li> <li>accessing <code>.value</code></li> <li>boolean logic</li> <li>Custom classes</li> <li>mypy and types</li> <li>pytest compatibility, including <code>__eq__</code> vs <code>__ne__</code></li> </ul>","title":"Usage"}]})