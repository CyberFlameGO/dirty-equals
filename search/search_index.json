{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Doing dirty (but extremely useful) things with equals. dirty-equals is a python library that (mis)uses the __eq__ method to make python code (generally unit tests) more declarative and therefore easier to read and write. dirty-equals can be used in whatever context you like, but it comes into its own when writing unit tests for applications where you're commonly checking the response to API calls and the contents of a database. Usage \u00b6 Here's a trivial example of what dirty-equals can do: Trival Usage from dirty_equals import IsPositive assert 1 == IsPositive #(1)! assert - 2 == IsPositive # this will fail! (2) This assert will pass since 1 is indeed positive, so the result of 1 == IsPositive is True . This will fail (raise a AssertionError ) since -2 is not positive, so the result of -2 == IsPositive is False . Not that interesting yet! , but consider the following unit test code using dirty-equals : More Powerful Usage from dirty_equals import IsJson , IsNow , IsPositiveInt , IsStr def test_user_endpoint ( client : HttpClient , db_conn : Database ): client . pust ( '/users/create/' , data =... ) user_data = db_conn . fetchrow ( 'select * from users' ) assert user_data == { 'id' : IsPositiveInt , #(1)! 'username' : 'samuelcolvin' , #(2)! 'avatar_file' : IsStr ( regex = r '/[a-z0-9\\-] {10} /example\\.png' ), #(3)! 'settings_json' : IsJson ({ 'theme' : 'dark' , 'language' : 'en' }), #(4)! 'created_ts' : IsNow ( delta = 3 ), #(5)! } We don't actually care what the id is, just that it's present, it's an int and it's positive. We can use a normal key and value here since we know exactly what value username should have before we test it. avatar_file is a string, but we don't know all of the string before the assert , just the format (regex) it should match. settings_json is a JSON string, but it's simpler and more robust to confirm it represents a particular python object rather than compare strings. created_at is a datetime , although we don't know (or care) about its exact value; since the user was just created we know it must be close to now. delta is optional, it defaults to 2 seconds. Without dirty-equals , you'd have to compare individual fields and/or modify some fields before comparison - the test would not be declarative or as clear. dirty-equals can do so much more than that, for example: PartialDict let's you compare a subset of a dictionary IsStrictDict let's you confirm order in a dictionary IsList and IsTuple lets you compare partial lists and tuples, with or without order constraints nesting any of these types inside any others IsInstance lets you simply confirm the type of an object You can even use boolean operators | and & to combine multiple conditions and much more... Installation \u00b6 Simply: pip install dirty-equals dirty-equals requires Python 3.7+ .","title":"Introduction"},{"location":"#usage","text":"Here's a trivial example of what dirty-equals can do: Trival Usage from dirty_equals import IsPositive assert 1 == IsPositive #(1)! assert - 2 == IsPositive # this will fail! (2) This assert will pass since 1 is indeed positive, so the result of 1 == IsPositive is True . This will fail (raise a AssertionError ) since -2 is not positive, so the result of -2 == IsPositive is False . Not that interesting yet! , but consider the following unit test code using dirty-equals : More Powerful Usage from dirty_equals import IsJson , IsNow , IsPositiveInt , IsStr def test_user_endpoint ( client : HttpClient , db_conn : Database ): client . pust ( '/users/create/' , data =... ) user_data = db_conn . fetchrow ( 'select * from users' ) assert user_data == { 'id' : IsPositiveInt , #(1)! 'username' : 'samuelcolvin' , #(2)! 'avatar_file' : IsStr ( regex = r '/[a-z0-9\\-] {10} /example\\.png' ), #(3)! 'settings_json' : IsJson ({ 'theme' : 'dark' , 'language' : 'en' }), #(4)! 'created_ts' : IsNow ( delta = 3 ), #(5)! } We don't actually care what the id is, just that it's present, it's an int and it's positive. We can use a normal key and value here since we know exactly what value username should have before we test it. avatar_file is a string, but we don't know all of the string before the assert , just the format (regex) it should match. settings_json is a JSON string, but it's simpler and more robust to confirm it represents a particular python object rather than compare strings. created_at is a datetime , although we don't know (or care) about its exact value; since the user was just created we know it must be close to now. delta is optional, it defaults to 2 seconds. Without dirty-equals , you'd have to compare individual fields and/or modify some fields before comparison - the test would not be declarative or as clear. dirty-equals can do so much more than that, for example: PartialDict let's you compare a subset of a dictionary IsStrictDict let's you confirm order in a dictionary IsList and IsTuple lets you compare partial lists and tuples, with or without order constraints nesting any of these types inside any others IsInstance lets you simply confirm the type of an object You can even use boolean operators | and & to combine multiple conditions and much more...","title":"Usage"},{"location":"#installation","text":"Simply: pip install dirty-equals dirty-equals requires Python 3.7+ .","title":"Installation"},{"location":"boolean-logic/","text":"","title":"Boolean Logic"},{"location":"types/","text":"Numeric Types \u00b6 IsInt \u00b6 Checks that a value is an integer, but not a bool ( True or False ) or a float. IsInt from dirty_equals import IsInt assert 1 == IsInt assert - 2 == IsInt assert 1.0 != IsInt assert 'foobar' != IsInt assert True != IsInt #(1)! This might not be what you expect since instance(True, int) is True but to me, it doesn't make sense for booleans to be allowed as integers in general. IsFloat \u00b6 Checks that a value is a float. IsFloat from dirty_equals import IsFloat assert 1.0 == IsFloat assert 1 != IsFloat IsPositive \u00b6 Check that a value is positive ( > 0 ), can be an int , a float or a Decimal (or indeed any value which implements __gt__ for 0 ). IsPositive from decimal import Decimal from dirty_equals import IsPositive assert 1.0 == IsPositive assert 1 == IsPositive assert Decimal ( '3.14' ) == IsPositive assert 0 != IsPositive assert - 1 != IsPositive IsNegative \u00b6 Check that a value is negative ( < 0 ), can be an int , a float or a Decimal (or indeed any value which implements __lt__ for 0 ). IsNegative from decimal import Decimal from dirty_equals import IsNegative assert - 1.0 == IsNegative assert - 1 == IsNegative assert Decimal ( '-3.14' ) == IsNegative assert 0 != IsNegative assert 1 != IsNegative IsNonNegative \u00b6 Check that a value is positive or zero ( >= 0 ), can be an int , a float or a Decimal (or indeed any value which implements __ge__ for 0 ). IsNonNegative from decimal import Decimal from dirty_equals import IsNonNegative assert 1.0 == IsNonNegative assert 1 == IsNonNegative assert Decimal ( '3.14' ) == IsNonNegative assert 0 == IsNonNegative assert - 1 != IsNonNegative assert Decimal ( '0' ) == IsNonPositive IsNonPositive \u00b6 Check that a value is negative or zero ( <=0 ), can be an int , a float or a Decimal (or indeed any value which implements __le__ for 0 ). IsNonPositive from decimal import Decimal from dirty_equals import IsNonPositive assert - 1.0 == IsNonPositive assert - 1 == IsNonPositive assert Decimal ( '-3.14' ) == IsNonPositive assert 0 == IsNonPositive assert 1 != IsNonPositive assert Decimal ( '-0' ) == IsNonPositive assert Decimal ( '0' ) == IsNonPositive IsPositiveInt \u00b6 Like IsPositive but only for int s. IsPositiveInt from decimal import Decimal from dirty_equals import IsPositiveInt assert 1 == IsPositiveInt assert 1.0 != IsPositiveInt assert Decimal ( '3.14' ) != IsPositiveInt assert 0 != IsPositiveInt assert - 1 != IsPositiveInt IsNegativeInt \u00b6 Like IsNegative but only for int s. IsNegativeInt from decimal import Decimal from dirty_equals import IsNegativeInt assert - 1 == IsNegativeInt assert - 1.0 != IsNegativeInt assert Decimal ( '-3.14' ) != IsNegativeInt assert 0 != IsNegativeInt assert 1 != IsNegativeInt IsPositiveFloat \u00b6 Like IsPositive but only for float s. IsPositiveFloat from decimal import Decimal from dirty_equals import IsPositiveFloat assert 1.0 == IsPositiveFloat assert 1 != IsPositiveFloat assert Decimal ( '3.14' ) != IsPositiveFloat assert 0.0 != IsPositiveFloat assert - 1.0 != IsPositiveFloat IsNegativeFloat \u00b6 Like IsNegative but only for float s. IsNegativeFloat from decimal import Decimal from dirty_equals import IsNegativeFloat assert - 1.0 == IsNegativeFloat assert - 1 != IsNegativeFloat assert Decimal ( '-3.14' ) != IsNegativeFloat assert 0.0 != IsNegativeFloat assert 1.0 != IsNegativeFloat IsApprox \u00b6 IsNumber \u00b6 IsNumeric \u00b6 Date and Time Types \u00b6 IsDatetime \u00b6 IsNow \u00b6 Dictionary Types \u00b6 IsDict \u00b6 IsPartialDict \u00b6 IsStrictDict \u00b6 List and Tuples Types \u00b6 HasLen \u00b6 IsList \u00b6 IsTuple \u00b6 IsListOrTuple \u00b6 String Types \u00b6 IsStr \u00b6 IsBytes \u00b6 IsAnyStr \u00b6 Other Types \u00b6 FunctionCheck \u00b6 IsInstance \u00b6 IsJson \u00b6 IsUUID \u00b6 AnyThing \u00b6","title":"Types"},{"location":"types/#numeric-types","text":"","title":"Numeric Types"},{"location":"types/#isint","text":"Checks that a value is an integer, but not a bool ( True or False ) or a float. IsInt from dirty_equals import IsInt assert 1 == IsInt assert - 2 == IsInt assert 1.0 != IsInt assert 'foobar' != IsInt assert True != IsInt #(1)! This might not be what you expect since instance(True, int) is True but to me, it doesn't make sense for booleans to be allowed as integers in general.","title":"IsInt"},{"location":"types/#isfloat","text":"Checks that a value is a float. IsFloat from dirty_equals import IsFloat assert 1.0 == IsFloat assert 1 != IsFloat","title":"IsFloat"},{"location":"types/#ispositive","text":"Check that a value is positive ( > 0 ), can be an int , a float or a Decimal (or indeed any value which implements __gt__ for 0 ). IsPositive from decimal import Decimal from dirty_equals import IsPositive assert 1.0 == IsPositive assert 1 == IsPositive assert Decimal ( '3.14' ) == IsPositive assert 0 != IsPositive assert - 1 != IsPositive","title":"IsPositive"},{"location":"types/#isnegative","text":"Check that a value is negative ( < 0 ), can be an int , a float or a Decimal (or indeed any value which implements __lt__ for 0 ). IsNegative from decimal import Decimal from dirty_equals import IsNegative assert - 1.0 == IsNegative assert - 1 == IsNegative assert Decimal ( '-3.14' ) == IsNegative assert 0 != IsNegative assert 1 != IsNegative","title":"IsNegative"},{"location":"types/#isnonnegative","text":"Check that a value is positive or zero ( >= 0 ), can be an int , a float or a Decimal (or indeed any value which implements __ge__ for 0 ). IsNonNegative from decimal import Decimal from dirty_equals import IsNonNegative assert 1.0 == IsNonNegative assert 1 == IsNonNegative assert Decimal ( '3.14' ) == IsNonNegative assert 0 == IsNonNegative assert - 1 != IsNonNegative assert Decimal ( '0' ) == IsNonPositive","title":"IsNonNegative"},{"location":"types/#isnonpositive","text":"Check that a value is negative or zero ( <=0 ), can be an int , a float or a Decimal (or indeed any value which implements __le__ for 0 ). IsNonPositive from decimal import Decimal from dirty_equals import IsNonPositive assert - 1.0 == IsNonPositive assert - 1 == IsNonPositive assert Decimal ( '-3.14' ) == IsNonPositive assert 0 == IsNonPositive assert 1 != IsNonPositive assert Decimal ( '-0' ) == IsNonPositive assert Decimal ( '0' ) == IsNonPositive","title":"IsNonPositive"},{"location":"types/#ispositiveint","text":"Like IsPositive but only for int s. IsPositiveInt from decimal import Decimal from dirty_equals import IsPositiveInt assert 1 == IsPositiveInt assert 1.0 != IsPositiveInt assert Decimal ( '3.14' ) != IsPositiveInt assert 0 != IsPositiveInt assert - 1 != IsPositiveInt","title":"IsPositiveInt"},{"location":"types/#isnegativeint","text":"Like IsNegative but only for int s. IsNegativeInt from decimal import Decimal from dirty_equals import IsNegativeInt assert - 1 == IsNegativeInt assert - 1.0 != IsNegativeInt assert Decimal ( '-3.14' ) != IsNegativeInt assert 0 != IsNegativeInt assert 1 != IsNegativeInt","title":"IsNegativeInt"},{"location":"types/#ispositivefloat","text":"Like IsPositive but only for float s. IsPositiveFloat from decimal import Decimal from dirty_equals import IsPositiveFloat assert 1.0 == IsPositiveFloat assert 1 != IsPositiveFloat assert Decimal ( '3.14' ) != IsPositiveFloat assert 0.0 != IsPositiveFloat assert - 1.0 != IsPositiveFloat","title":"IsPositiveFloat"},{"location":"types/#isnegativefloat","text":"Like IsNegative but only for float s. IsNegativeFloat from decimal import Decimal from dirty_equals import IsNegativeFloat assert - 1.0 == IsNegativeFloat assert - 1 != IsNegativeFloat assert Decimal ( '-3.14' ) != IsNegativeFloat assert 0.0 != IsNegativeFloat assert 1.0 != IsNegativeFloat","title":"IsNegativeFloat"},{"location":"types/#isapprox","text":"","title":"IsApprox"},{"location":"types/#isnumber","text":"","title":"IsNumber"},{"location":"types/#isnumeric","text":"","title":"IsNumeric"},{"location":"types/#date-and-time-types","text":"","title":"Date and Time Types"},{"location":"types/#isdatetime","text":"","title":"IsDatetime"},{"location":"types/#isnow","text":"","title":"IsNow"},{"location":"types/#dictionary-types","text":"","title":"Dictionary Types"},{"location":"types/#isdict","text":"","title":"IsDict"},{"location":"types/#ispartialdict","text":"","title":"IsPartialDict"},{"location":"types/#isstrictdict","text":"","title":"IsStrictDict"},{"location":"types/#list-and-tuples-types","text":"","title":"List and Tuples Types"},{"location":"types/#haslen","text":"","title":"HasLen"},{"location":"types/#islist","text":"","title":"IsList"},{"location":"types/#istuple","text":"","title":"IsTuple"},{"location":"types/#islistortuple","text":"","title":"IsListOrTuple"},{"location":"types/#string-types","text":"","title":"String Types"},{"location":"types/#isstr","text":"","title":"IsStr"},{"location":"types/#isbytes","text":"","title":"IsBytes"},{"location":"types/#isanystr","text":"","title":"IsAnyStr"},{"location":"types/#other-types","text":"","title":"Other Types"},{"location":"types/#functioncheck","text":"","title":"FunctionCheck"},{"location":"types/#isinstance","text":"","title":"IsInstance"},{"location":"types/#isjson","text":"","title":"IsJson"},{"location":"types/#isuuid","text":"","title":"IsUUID"},{"location":"types/#anything","text":"","title":"AnyThing"}]}