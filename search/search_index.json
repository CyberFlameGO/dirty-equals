{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Doing dirty (but extremely useful) things with equals. dirty-equals is a python library that (mis)uses the __eq__ method to make python code (generally unit tests) more declarative and therefore easier to read and write. Usage \u00b6 Here's a trivial example of what dirty-equals can do: Trival Usage from dirty_equals import IsPositive assert 1 == IsPositive #(1)! assert - 2 == IsPositive # this will fail! (2) This assert will pass since 1 is indeed positive, so the result of 1 == IsPositive is True . This will fail (raise a AssertionError ) since -2 is not positive, so the result of -2 == IsPositive is False . That doesn't look very useful yet, but consider the following unit test code using dirty-equals : More Powerful Usage from dirty_equals import IsJson , IsNow , IsPositiveInt , IsStr ... # user_data is a dict returned from a database or API which we want to test assert user_data == { 'id' : IsPositiveInt , #(1)! 'username' : 'samuelcolvin' , #(2)! 'avatar_file' : IsStr ( regex = r '/[a-z0-9\\-] {10} /example\\.png' ), #(3)! 'settings_json' : IsJson ({ 'theme' : 'dark' , 'language' : 'en' }), #(4)! 'created_ts' : IsNow ( delta = 3 ), #(5)! } We don't actually care what the id is, just that it's present, it's an int and it's positive. We can use a normal key and value here since we know exactly what value username should have before we test it. avatar_file is a string, but we don't know all of the string before the assert , just the format (regex) it should match. settings_json is a JSON string, but it's simpler and more robust to confirm it represents a particular python object rather than compare strings. created_at is a datetime , although we don't know (or care) about its exact value; since the user was just created we know it must be close to now. delta is optional, it defaults to 2 seconds. Without dirty-equals , you'd have to compare individual fields and/or modify some fields before comparison - the test would not be declarative or as clear. dirty-equals can do so much more than that, for example: PartialDict let's you compare a subset of a dictionary IsStrictDict let's you confirm order in a dictionary IsList and IsTuple lets you compare partial lists and tuples, with or without order constraints IsInstance lets you simply confirm the type of an object You can even use boolean operators | and & to combine multiple conditions and much more... Installation \u00b6 Simply: pip install dirty-equals dirty-equals requires Python 3.7+ .","title":"Introduction"},{"location":"#usage","text":"Here's a trivial example of what dirty-equals can do: Trival Usage from dirty_equals import IsPositive assert 1 == IsPositive #(1)! assert - 2 == IsPositive # this will fail! (2) This assert will pass since 1 is indeed positive, so the result of 1 == IsPositive is True . This will fail (raise a AssertionError ) since -2 is not positive, so the result of -2 == IsPositive is False . That doesn't look very useful yet, but consider the following unit test code using dirty-equals : More Powerful Usage from dirty_equals import IsJson , IsNow , IsPositiveInt , IsStr ... # user_data is a dict returned from a database or API which we want to test assert user_data == { 'id' : IsPositiveInt , #(1)! 'username' : 'samuelcolvin' , #(2)! 'avatar_file' : IsStr ( regex = r '/[a-z0-9\\-] {10} /example\\.png' ), #(3)! 'settings_json' : IsJson ({ 'theme' : 'dark' , 'language' : 'en' }), #(4)! 'created_ts' : IsNow ( delta = 3 ), #(5)! } We don't actually care what the id is, just that it's present, it's an int and it's positive. We can use a normal key and value here since we know exactly what value username should have before we test it. avatar_file is a string, but we don't know all of the string before the assert , just the format (regex) it should match. settings_json is a JSON string, but it's simpler and more robust to confirm it represents a particular python object rather than compare strings. created_at is a datetime , although we don't know (or care) about its exact value; since the user was just created we know it must be close to now. delta is optional, it defaults to 2 seconds. Without dirty-equals , you'd have to compare individual fields and/or modify some fields before comparison - the test would not be declarative or as clear. dirty-equals can do so much more than that, for example: PartialDict let's you compare a subset of a dictionary IsStrictDict let's you confirm order in a dictionary IsList and IsTuple lets you compare partial lists and tuples, with or without order constraints IsInstance lets you simply confirm the type of an object You can even use boolean operators | and & to combine multiple conditions and much more...","title":"Usage"},{"location":"#installation","text":"Simply: pip install dirty-equals dirty-equals requires Python 3.7+ .","title":"Installation"},{"location":"boolean-logic/","text":"","title":"Boolean Logic"},{"location":"types/","text":"Numeric Types \u00b6 IsInt \u00b6 Checks that a value is an integer, but not a bool ( True or False ) or a float. IsInt from dirty_equals import IsInt assert 1 == IsInt assert - 2 == IsInt assert 1.0 != IsInt assert 'foobar' != IsInt assert True != IsInt #(1)! This might not be what you expect since instance(True, int) is True but to me, it doesn't make sense for booleans to be allowed as integers in general. IsFloat \u00b6 Checks that a value is a float. IsFloat from dirty_equals import IsFloat assert 1.0 == IsFloat assert 1 != IsFloat IsPositive \u00b6 IsPositive from dirty_equals import IsPositive assert 1.0 == IsPositive assert 1 == IsPositive assert 0 == IsPositive assert - 1 == IsPositive IsNegative \u00b6 IsNonPositive \u00b6 IsNonNegative \u00b6 IsPositiveInt \u00b6 IsNegativeInt \u00b6 IsPositiveFloat \u00b6 IsNegativeFloat \u00b6 IsApprox \u00b6 IsNumber \u00b6 IsNumeric \u00b6 Date and Time Types \u00b6 IsDatetime \u00b6 IsNow \u00b6 Dictionary Types \u00b6 IsDict \u00b6 IsPartialDict \u00b6 IsStrictDict \u00b6 List and Tuples Types \u00b6 HasLen \u00b6 IsList \u00b6 IsTuple \u00b6 IsListOrTuple \u00b6 String Types \u00b6 IsStr \u00b6 IsBytes \u00b6 IsAnyStr \u00b6 Other Types \u00b6 FunctionCheck \u00b6 IsInstance \u00b6 IsJson \u00b6 IsUUID \u00b6 AnyThing \u00b6","title":"Types"},{"location":"types/#numeric-types","text":"","title":"Numeric Types"},{"location":"types/#isint","text":"Checks that a value is an integer, but not a bool ( True or False ) or a float. IsInt from dirty_equals import IsInt assert 1 == IsInt assert - 2 == IsInt assert 1.0 != IsInt assert 'foobar' != IsInt assert True != IsInt #(1)! This might not be what you expect since instance(True, int) is True but to me, it doesn't make sense for booleans to be allowed as integers in general.","title":"IsInt"},{"location":"types/#isfloat","text":"Checks that a value is a float. IsFloat from dirty_equals import IsFloat assert 1.0 == IsFloat assert 1 != IsFloat","title":"IsFloat"},{"location":"types/#ispositive","text":"IsPositive from dirty_equals import IsPositive assert 1.0 == IsPositive assert 1 == IsPositive assert 0 == IsPositive assert - 1 == IsPositive","title":"IsPositive"},{"location":"types/#isnegative","text":"","title":"IsNegative"},{"location":"types/#isnonpositive","text":"","title":"IsNonPositive"},{"location":"types/#isnonnegative","text":"","title":"IsNonNegative"},{"location":"types/#ispositiveint","text":"","title":"IsPositiveInt"},{"location":"types/#isnegativeint","text":"","title":"IsNegativeInt"},{"location":"types/#ispositivefloat","text":"","title":"IsPositiveFloat"},{"location":"types/#isnegativefloat","text":"","title":"IsNegativeFloat"},{"location":"types/#isapprox","text":"","title":"IsApprox"},{"location":"types/#isnumber","text":"","title":"IsNumber"},{"location":"types/#isnumeric","text":"","title":"IsNumeric"},{"location":"types/#date-and-time-types","text":"","title":"Date and Time Types"},{"location":"types/#isdatetime","text":"","title":"IsDatetime"},{"location":"types/#isnow","text":"","title":"IsNow"},{"location":"types/#dictionary-types","text":"","title":"Dictionary Types"},{"location":"types/#isdict","text":"","title":"IsDict"},{"location":"types/#ispartialdict","text":"","title":"IsPartialDict"},{"location":"types/#isstrictdict","text":"","title":"IsStrictDict"},{"location":"types/#list-and-tuples-types","text":"","title":"List and Tuples Types"},{"location":"types/#haslen","text":"","title":"HasLen"},{"location":"types/#islist","text":"","title":"IsList"},{"location":"types/#istuple","text":"","title":"IsTuple"},{"location":"types/#islistortuple","text":"","title":"IsListOrTuple"},{"location":"types/#string-types","text":"","title":"String Types"},{"location":"types/#isstr","text":"","title":"IsStr"},{"location":"types/#isbytes","text":"","title":"IsBytes"},{"location":"types/#isanystr","text":"","title":"IsAnyStr"},{"location":"types/#other-types","text":"","title":"Other Types"},{"location":"types/#functioncheck","text":"","title":"FunctionCheck"},{"location":"types/#isinstance","text":"","title":"IsInstance"},{"location":"types/#isjson","text":"","title":"IsJson"},{"location":"types/#isuuid","text":"","title":"IsUUID"},{"location":"types/#anything","text":"","title":"AnyThing"}]}